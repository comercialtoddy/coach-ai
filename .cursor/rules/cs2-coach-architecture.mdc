---
description: 
globs: 
alwaysApply: true
---
# üèóÔ∏è CS2 COACH AI - ARCHITECTURAL PATTERNS

## **ARQUITETURA TIER 1 - PADR√ïES OBRIGAT√ìRIOS**

### üéØ **SISTEMA EXISTENTE (BASE PARA EXPANS√ÉO)**

O projeto j√° possui uma **arquitetura Tier 1 implementada** que deve ser respeitada e expandida, nunca substitu√≠da.

### **üìÅ ESTRUTURA DE DIRET√ìRIOS ESTABELECIDA**

```
src/
‚îú‚îÄ‚îÄ main/              # Processo principal Electron
‚îÇ   ‚îî‚îÄ‚îÄ main.js        # [main.js](mdc:src/main/main.js)
‚îú‚îÄ‚îÄ coach/             # Sistema de prompts e coaching
‚îÇ   ‚îú‚îÄ‚îÄ prompt.js      # [prompt.js](mdc:src/coach/prompt.js) - Prompts principais
‚îÇ   ‚îî‚îÄ‚îÄ elitePrompt.js # [elitePrompt.js](mdc:src/coach/elitePrompt.js) - Sistema elite
‚îú‚îÄ‚îÄ utils/             # Utilit√°rios e engines avan√ßados
‚îÇ   ‚îú‚îÄ‚îÄ geminiClient.js      # [geminiClient.js](mdc:src/utils/geminiClient.js)
‚îÇ   ‚îú‚îÄ‚îÄ autoAnalyzer.js      # [autoAnalyzer.js](mdc:src/utils/autoAnalyzer.js)
‚îÇ   ‚îú‚îÄ‚îÄ tokenOptimizer.js    # [tokenOptimizer.js](mdc:src/utils/tokenOptimizer.js)
‚îÇ   ‚îú‚îÄ‚îÄ strategicInference.js # [strategicInference.js](mdc:src/utils/strategicInference.js)
‚îÇ   ‚îî‚îÄ‚îÄ eventDetector.js     # [eventDetector.js](mdc:src/utils/eventDetector.js)
‚îú‚îÄ‚îÄ database/          # Sistemas de dados e mem√≥ria
‚îÇ   ‚îú‚îÄ‚îÄ roundDatabase.js  # [roundDatabase.js](mdc:src/database/roundDatabase.js)
‚îÇ   ‚îî‚îÄ‚îÄ geminiMemory.js   # [geminiMemory.js](mdc:src/database/geminiMemory.js)
‚îî‚îÄ‚îÄ themes/           # Interface e overlay
    ‚îî‚îÄ‚îÄ clean-coach/  # Tema principal
```

## **üîß PADR√ïES DE INTEGRA√á√ÉO OBRIGAT√ìRIOS**

### **1. Sistema de IA (Gemini Integration)**

#### **‚úÖ SEMPRE usar GeminiClient existente:**
```javascript
// CORRETO - Usar o cliente existente
const GeminiClient = require('../utils/geminiClient.js');

class NewService {
    constructor() {
        this.geminiClient = new GeminiClient();
    }
    
    async generateAnalysis(data) {
        // Usar sistema de prompts existente
        const promptData = buildPromptWithGSI('new_analysis_type', data);
        return await this.geminiClient.generateResponse(
            promptData.userPrompt,
            promptData.systemPrompt
        );
    }
}
```

#### **‚ùå NUNCA criar clientes Gemini separados:**
```javascript
// ERRADO - N√£o fazer
const { GoogleGenerativeAI } = require('@google/generative-ai');
// Isso quebra a arquitetura existente
```

### **2. Sistema de Prompts (Coach Integration)**

#### **‚úÖ EXPANDIR o sistema existente:**
```javascript
// Em src/coach/prompt.js - ADICIONAR novos tipos
function buildPromptWithGSI(analysisType, gameData, context = '') {
    // ... c√≥digo existente ...
    
    switch (analysisType) {
        // Casos existentes...
        
        case 'new_analysis_type':  // ADICIONAR aqui
            userMessage = `NOVO TIPO DE AN√ÅLISE\n${gsiData}\nESTRAT√âGIA ESPEC√çFICA`;
            break;
    }
}
```

#### **‚úÖ USAR ElitePromptSystem para funcionalidades avan√ßadas:**
```javascript
// Para recursos Tier 1
const ElitePromptSystem = require('../coach/elitePrompt.js');

class AdvancedAnalyzer {
    constructor() {
        this.elitePromptSystem = new ElitePromptSystem();
    }
    
    async analyze(gameData) {
        return this.elitePromptSystem.generateElitePrompt(
            'advanced_analysis',
            gameData,
            'contexto espec√≠fico'
        );
    }
}
```

### **3. Sistema de Dados (Database Integration)**

#### **‚úÖ USAR roundDatabase para dados de jogo:**
```javascript
// CORRETO - Integrar com sistema existente
const RoundDatabase = require('../database/roundDatabase.js');

class NewGameAnalyzer {
    constructor() {
        this.roundDb = new RoundDatabase();
    }
    
    analyzePattern() {
        const recentRounds = this.roundDb.getRecentRounds(10);
        const playerStats = this.roundDb.getPlayerStats();
        // Usar dados reais do sistema
    }
}
```

#### **‚úÖ USAR geminiMemory para persist√™ncia de IA:**
```javascript
// CORRETO - Sistema de mem√≥ria inteligente
const GeminiMemory = require('../database/geminiMemory.js');

async function storeAnalysisResult(analysis, context) {
    const memory = new GeminiMemory();
    await memory.storeConversation({
        input: context,
        output: analysis,
        effectiveness: 'positive',
        timestamp: Date.now()
    });
}
```

### **4. Sistema de Otimiza√ß√£o (Performance)**

#### **‚úÖ SEMPRE usar TokenOptimizer:**
```javascript
// OBRIGAT√ìRIO para novos recursos
const TokenOptimizer = require('../utils/tokenOptimizer.js');

class NewAPIIntegration {
    constructor() {
        this.tokenOptimizer = new TokenOptimizer();
    }
    
    async processGameData(gameData) {
        // Otimizar antes de enviar para IA
        const optimizedData = this.tokenOptimizer.optimizeGameData(
            gameData, 
            'new_analysis_type'
        );
        return optimizedData;
    }
}
```

#### **‚úÖ INTEGRAR com StrategicInference:**
```javascript
// Para funcionalidades de predi√ß√£o
const StrategicInference = require('../utils/strategicInference.js');

class PredictiveAnalyzer {
    constructor() {
        this.strategicInference = new StrategicInference();
    }
    
    async predictOutcome(gameData, previousData) {
        this.strategicInference.updateInference(gameData, previousData);
        return this.strategicInference.generatePredictiveAnalysis(
            'prediction_phase',
            gameData
        );
    }
}
```

## **üì° PADR√ïES DE API E SERVI√áOS**

### **üîó APIs Externas (Tracker.gg, Steam, etc.)**

#### **‚úÖ ESTRUTURA PADR√ÉO para novos servi√ßos:**
```javascript
// Template para novos servi√ßos de API
class ExternalAPIService {
    constructor(apiKey, baseUrl) {
        this.apiKey = apiKey;
        this.baseUrl = baseUrl;
        this.rateLimiter = new RateLimiter();
        this.cache = new Cache();
    }
    
    async fetchData(endpoint, params) {
        // 1. Verificar cache primeiro
        const cached = await this.cache.get(cacheKey);
        if (cached) return cached;
        
        // 2. Rate limiting
        await this.rateLimiter.wait();
        
        // 3. Request com error handling
        try {
            const response = await axios.get(`${this.baseUrl}${endpoint}`, {
                headers: { 'Authorization': `Bearer ${this.apiKey}` },
                timeout: 5000,
                params
            });
            
            // 4. Cache resultado
            await this.cache.set(cacheKey, response.data, TTL);
            
            return response.data;
        } catch (error) {
            logger.error(`API Error:`, error);
            throw new APIError(`Failed to fetch ${endpoint}`, error);
        }
    }
}
```

### **‚ö° GSI Integration (Game State Integration)**

#### **‚úÖ USAR padr√µes existentes do main.js:**
```javascript
// Seguir padr√£o do handleCS2Data em main.js
class NewGSIHandler {
    handleGameData(gameData) {
        // 1. Validar dados GSI
        if (!this.validateGSIData(gameData)) {
            return;
        }
        
        // 2. Processar com sistema existente
        const processedData = this.processGameData(gameData);
        
        // 3. Integrar com AutoAnalyzer
        this.triggerAnalysis(processedData);
    }
    
    triggerAnalysis(gameData) {
        // Usar AutoAnalyzer existente
        if (this.autoAnalyzer) {
            this.autoAnalyzer.analyzeGameState(gameData);
        }
    }
}
```

## **üé® PADR√ïES DE UI/UX (Electron + Overlay)**

### **‚úÖ USAR tema clean-coach existente:**
```javascript
// Expandir temas existentes em src/themes/clean-coach/
// NUNCA criar sistemas de UI paralelos

// Para novos componentes:
class NewUIComponent {
    constructor() {
        this.loadExistingTheme();
        this.integrateWithShell();
    }
    
    loadExistingTheme() {
        // Usar CSS e estrutura do clean-coach
        this.themeCSS = require('./clean-coach/index.css');
    }
    
    integrateWithShell() {
        // Integrar com shell.js existente
        if (window.CoachAI) {
            window.CoachAI.registerComponent(this);
        }
    }
}
```

### **üì± Overlay System Integration**

#### **‚úÖ SEGUIR padr√£o de overlay existente:**
```javascript
// Usar estrutura do main.js para overlays
createOverlay() {
    this.overlayWindow = new BrowserWindow({
        // Usar configura√ß√µes existentes do main.js
        width: 400,
        height: 300,
        transparent: true,
        frame: false,
        alwaysOnTop: true,
        skipTaskbar: true,
        // ... outras configs do projeto
    });
}
```

## **üîÑ PADR√ïES DE EVENTOS E COMUNICA√á√ÉO**

### **‚úÖ IPC Communication (Electron)**
```javascript
// USAR padr√µes do main.js
// Main Process
ipcMain.handle('new-feature-request', async (event, data) => {
    try {
        const result = await this.newFeatureHandler.process(data);
        return { success: true, data: result };
    } catch (error) {
        return { success: false, error: error.message };
    }
});

// Renderer Process
const result = await window.electronAPI.invoke('new-feature-request', data);
```

### **‚úÖ Event Detection Integration**
```javascript
// EXPANDIR eventDetector.js existente
class EnhancedEventDetector extends EventDetector {
    constructor() {
        super();
        this.addNewEventTypes();
    }
    
    addNewEventTypes() {
        // Adicionar novos tipos sem quebrar existentes
        this.eventPriorities['new_event_type'] = 'HIGH';
        this.thresholds['new_event_type'] = { /* thresholds */ };
    }
}
```

## **üß† PADR√ïES DE MACHINE LEARNING**

### **‚úÖ ESTRUTURA para novos modelos ML:**
```javascript
// Template para modelos ML
class MLModel {
    constructor(modelPath) {
        this.model = null;
        this.isLoaded = false;
        this.modelPath = modelPath;
    }
    
    async loadModel() {
        // Carregar modelo com error handling
        try {
            this.model = await tf.loadLayersModel(this.modelPath);
            this.isLoaded = true;
        } catch (error) {
            logger.error('Failed to load ML model:', error);
            throw error;
        }
    }
    
    async predict(inputData) {
        if (!this.isLoaded) {
            await this.loadModel();
        }
        
        // Preprocessar dados usando padr√µes existentes
        const preprocessed = this.preprocessData(inputData);
        
        // Fazer predi√ß√£o
        const prediction = this.model.predict(preprocessed);
        
        // P√≥s-processar resultado
        return this.postprocessPrediction(prediction);
    }
}
```

## **üìä PADR√ïES DE LOGGING E MONITORING**

### **‚úÖ LOGGING consistente:**
```javascript
// Usar console.log estruturado como no projeto
console.log(`[NEW_SERVICE] Iniciando an√°lise: ${analysisType}`);
console.log(`[NEW_SERVICE] Dados processados: ${dataSize} bytes`);
console.error(`[NEW_SERVICE] Erro cr√≠tico:`, error);

// Para debugging (seguir padr√£o do projeto)
if (this.config.debug) {
    console.log(`[DEBUG] Estado interno:`, this.internalState);
}
```

## **‚öôÔ∏è CONFIGURATION PATTERNS**

### **‚úÖ USAR configura√ß√µes existentes:**
```javascript
// Integrar com configura√ß√µes do projeto
class NewService {
    constructor() {
        this.config = {
            // Usar padr√µes existentes
            useTokenOptimization: true,
            useStrategicInference: true,
            maxRetries: 3,
            timeout: 5000,
            debug: process.env.NODE_ENV === 'development'
        };
    }
}
```

## **üöÄ DEPLOYMENT E BUILD PATTERNS**

### **‚úÖ SEGUIR estrutura Electron existente:**
```javascript
// package.json - EXPANDIR, n√£o substituir
{
    "scripts": {
        "start": "electron src/main/main.js",
        "build": "electron-builder",
        // Adicionar novos scripts aqui
        "test:new-feature": "jest tests/new-feature",
        "lint:new-service": "eslint src/services/new-service.js"
    }
}
```

---

## **üéØ CHECKLIST DE CONFORMIDADE ARQUITETURAL**

### **‚úÖ Antes de implementar qualquer nova funcionalidade:**

1. **Integra√ß√£o verificada** com sistemas existentes
2. **Padr√µes de error handling** seguidos
3. **Sistema de logging** implementado
4. **Rate limiting** (se aplic√°vel) configurado
5. **Cache strategy** definida
6. **Token optimization** aplicada
7. **Configura√ß√µes** seguem padr√£o do projeto
8. **IPC communication** (se Electron) padronizada
9. **Event detection** integrado
10. **Performance** validada (< 100ms)

### **üö´ SINAIS DE VIOLA√á√ÉO ARQUITETURAL:**

- Cria√ß√£o de clientes AI paralelos
- Sistemas de prompt independentes
- Databases separados para dados similares
- UIs que n√£o integram com clean-coach
- APIs sem rate limiting ou cache
- Logs inconsistentes com padr√£o do projeto
- Configura√ß√µes hardcoded
- Fun√ß√µes que duplicam funcionalidade existente

---

## **LEMBRE-SE:**

> **"Esta arquitetura Tier 1 foi cuidadosamente projetada. Expanda, n√£o substitua."**

**TODA nova funcionalidade deve ser uma extens√£o natural do sistema existente, mantendo a coes√£o e performance de n√≠vel profissional.**

